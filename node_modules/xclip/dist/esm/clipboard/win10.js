import { fileURLToPath } from "node:url";
import { ClipboardType } from "../clipboard_interface";
import { getShell } from "../os";
import * as path from "path";
import { stripFinalNewline } from "../utils";
import { BaseClipboard } from "./base_clipboard";
class Win10Clipboard extends BaseClipboard {
    SCRIPT_PATH = "../../res/scripts/";
    async copyImage(imageFile) {
        const imageFilePath = fileURLToPath(imageFile);
        const script = path.join(__dirname, this.SCRIPT_PATH, "win32_set_clipboard_png.ps1");
        const params = [imageFilePath];
        try {
            const shell = getShell();
            await shell.runScript(script, params);
            return true;
        }
        catch (e) {
            return false;
        }
    }
    async copyTextPlain(textFile) {
        const textFilePath = fileURLToPath(textFile);
        const script = path.join(__dirname, this.SCRIPT_PATH, "win32_set_clipboard_text_plain.ps1");
        const params = [textFilePath];
        try {
            const shell = getShell();
            await shell.runScript(script, params);
            return true;
        }
        catch (e) {
            return false;
        }
    }
    async copyTextHtml(htmlFile) {
        const htmlFilePath = fileURLToPath(htmlFile);
        const script = path.join(__dirname, this.SCRIPT_PATH, "win32_set_clipboard_text_html.ps1");
        const params = [htmlFilePath];
        try {
            const shell = getShell();
            await shell.runScript(script, params);
            return true;
        }
        catch (e) {
            return false;
        }
    }
    onDetectType(types) {
        const detectedTypes = new Set();
        for (const type of types) {
            switch (type) {
                case "PNG":
                case "Bitmap":
                case "DeviceIndependentBitmap":
                    detectedTypes.add(ClipboardType.Image);
                    break;
                case "HTML Format":
                    detectedTypes.add(ClipboardType.Html);
                    break;
                case "Text":
                case "UnicodeText":
                    detectedTypes.add(ClipboardType.Text);
                    break;
            }
        }
        return detectedTypes;
    }
    async getContentType() {
        const script = path.join(__dirname, this.SCRIPT_PATH, "win32_get_clipboard_content_type.ps1");
        try {
            const shell = getShell();
            const data = await shell.runScript(script);
            console.debug("getClipboardContentType", data);
            const types = data.split(/\r\n|\n|\r/);
            return this.detectType(types);
        }
        catch (e) {
            return ClipboardType.Unknown;
        }
    }
    async getImage(imagePath) {
        if (!imagePath)
            return "";
        const script = path.join(__dirname, this.SCRIPT_PATH, "win10_save_clipboard_png.ps1");
        const shell = getShell();
        const data = await shell.runScript(script, [imagePath]);
        return stripFinalNewline(data);
    }
    async getTextPlain() {
        const script = path.join(__dirname, this.SCRIPT_PATH, "win32_get_clipboard_text_plain.ps1");
        const shell = getShell();
        const data = await shell.runScript(script);
        return stripFinalNewline(data);
    }
    async getTextHtml() {
        const script = path.join(__dirname, this.SCRIPT_PATH, "win32_get_clipboard_text_html.ps1");
        const shell = getShell();
        const data = await shell.runScript(script);
        return stripFinalNewline(data);
    }
}
export { Win10Clipboard };
